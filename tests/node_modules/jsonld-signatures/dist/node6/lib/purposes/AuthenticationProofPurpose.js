/*!
 * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

const ControllerProofPurpose = require('./ControllerProofPurpose');

module.exports = class AuthenticationProofPurpose extends ControllerProofPurpose {
  constructor({
    term = 'authentication',
    controller,
    challenge,
    date,
    domain,
    maxTimestampDelta = Infinity
  } = {}) {
    super({
      term,
      controller,
      date,
      maxTimestampDelta
    });

    if (typeof challenge !== 'string') {
      throw new TypeError('"challenge" must be a string.');
    }

    if (domain !== undefined && typeof domain !== 'string') {
      throw new TypeError('"domain" must be a string.');
    }

    this.challenge = challenge;
    this.domain = domain;
  }

  validate(proof, {
    verificationMethod,
    documentLoader,
    expansionMap
  }) {
    var _this = this,
        _superprop_callValidate = (..._args) => super.validate(..._args);

    return _asyncToGenerator(function* () {
      try {
        // check challenge
        if (proof.challenge !== _this.challenge) {
          throw new Error('The challenge is not as expected; ' + `challenge="${proof.challenge}", expected="${_this.challenge}"`);
        } // check domain


        if (_this.domain !== undefined && proof.domain !== _this.domain) {
          throw new Error('The domain is not as expected; ' + `domain="${proof.domain}", expected="${_this.domain}"`);
        }

        return _superprop_callValidate(proof, {
          verificationMethod,
          documentLoader,
          expansionMap
        });
      } catch (error) {
        return {
          valid: false,
          error
        };
      }
    })();
  }

  update(proof, {
    document,
    suite,
    documentLoader,
    expansionMap
  }) {
    var _this2 = this,
        _superprop_callUpdate = (..._args2) => super.update(..._args2);

    return _asyncToGenerator(function* () {
      proof = yield _superprop_callUpdate(proof, {
        document,
        suite,
        documentLoader,
        expansionMap
      });
      proof.challenge = _this2.challenge;

      if (_this2.domain !== undefined) {
        proof.domain = _this2.domain;
      }

      return proof;
    })();
  }

};