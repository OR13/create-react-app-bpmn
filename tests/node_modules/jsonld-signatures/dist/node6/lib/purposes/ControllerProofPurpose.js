/*!
 * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

const constants = require('../constants');

const jsonld = require('jsonld');

const ProofPurpose = require('./ProofPurpose');

module.exports = class ControllerProofPurpose extends ProofPurpose {
  /**
   * Creates a proof purpose that will validate whether or not the verification
   * method in a proof was authorized by its declared controller for the
   * proof's purpose.
   *
   * @param term {string} the `proofPurpose` term, as defined in the
   *    SECURITY_CONTEXT_URL `@context` or a URI if not defined in such.
   * @param [controller] {object} the description of the controller, if it
   *   is not to be dereferenced via a `documentLoader`.
   * @param [date] {string or Date or integer} the expected date for
   *   the creation of the proof.
   * @param [maxTimestampDelta] {integer} a maximum number of seconds that
   *   the date on the signature can deviate from, defaults to `Infinity`.
   */
  constructor({
    term,
    controller,
    date,
    maxTimestampDelta = Infinity
  } = {}) {
    super({
      term,
      date,
      maxTimestampDelta
    });

    if (controller !== undefined) {
      if (typeof controller !== 'object') {
        throw new TypeError('"controller" must be an object.');
      }

      this.controller = controller;
    }
  }

  validate(proof, {
    verificationMethod,
    documentLoader,
    expansionMap
  }) {
    var _this = this,
        _superprop_callValidate = (..._args) => super.validate(..._args);

    return _asyncToGenerator(function* () {
      try {
        const result = yield _superprop_callValidate(proof, {
          verificationMethod,
          documentLoader,
          expansionMap
        });

        if (!result.valid) {
          throw result.error;
        }

        const {
          id: verificationId
        } = verificationMethod; // if no `controller` specified, use verification method's

        if (_this.controller) {
          result.controller = _this.controller;
        } else {
          // support legacy `owner` property
          const {
            controller,
            owner
          } = verificationMethod;
          let controllerId;

          if (controller) {
            if (typeof controller === 'object') {
              controllerId = controller.id;
            } else if (typeof controller !== 'string') {
              throw new TypeError('"controller" must be a string representing a URL.');
            }

            controllerId = controller;
          } else if (owner) {
            if (typeof owner === 'object') {
              controllerId = owner.id;
            } else if (typeof owner !== 'string') {
              throw new TypeError('"owner" must be a string representing a URL.');
            }

            controllerId = owner;
          } // Note: `expansionMap` is intentionally not passed; we can safely drop
          // properties here and must allow for it


          const {
            '@graph': [framed = {}]
          } = yield jsonld.frame(controllerId, {
            '@context': constants.SECURITY_CONTEXT_URL,
            id: controllerId,
            [_this.term]: {
              '@embed': '@never',
              id: verificationId
            }
          }, {
            documentLoader,
            compactToRelative: false
          });
          result.controller = framed;
        }

        const verificationMethods = jsonld.getValues(result.controller, _this.term);
        result.valid = verificationMethods.some(vm => vm === verificationId || typeof vm === 'object' && vm.id === verificationId);

        if (!result.valid) {
          throw new Error(`Verification method "${verificationMethod.id}" not authorized ` + `by controller for proof purpose "${_this.term}".`);
        }

        return result;
      } catch (error) {
        return {
          valid: false,
          error
        };
      }
    })();
  }

};