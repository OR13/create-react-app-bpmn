/*!
 * Copyright (c) 2017-2018 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

const jsonld = require('jsonld');

const forge = require('node-forge');

const LinkedDataSignature2015 = require('./LinkedDataSignature2015');

module.exports = class GraphSignature2012 extends LinkedDataSignature2015 {
  constructor({
    privateKeyPem,
    publicKeyPem,
    creator,
    date,
    domain,
    nonce
  } = {}) {
    super({
      type: 'GraphSignature2012',
      privateKeyPem,
      publicKeyPem,
      creator,
      date,
      domain,
      nonce
    });
  }

  canonize(input, {
    documentLoader,
    expansionMap,
    skipExpansion
  }) {
    return _asyncToGenerator(function* () {
      return jsonld.canonize(input, {
        algorithm: 'URGNA2012',
        format: 'application/n-quads',
        documentLoader,
        expansionMap,
        skipExpansion
      });
    })();
  }
  /**
   * @param document {object} to be signed/verified.
   * @param proof {object}
   * @param documentLoader {function}
   * @param expansionMap {function}
   * @param compactProof {boolean}
   *
   * @returns {Promise<{Uint8Array}>}.
   */


  createVerifyData({
    document,
    proof,
    documentLoader,
    expansionMap
  }) {
    var _this = this;

    return _asyncToGenerator(function* () {
      const c14n = yield _this.canonize(document, {
        documentLoader,
        expansionMap
      });
      let verifyData = '';

      if (proof.nonce !== null && proof.nonce !== undefined) {
        verifyData += proof.nonce;
      }

      verifyData += proof.created;
      verifyData += c14n;

      if (proof.domain !== null && proof.domain !== undefined) {
        verifyData += '@' + proof.domain;
      }

      const buffer = new forge.util.ByteBuffer(verifyData, 'utf8');
      return forge.util.binary.raw.decode(buffer.getBytes());
    })();
  }

};