/*!
 * Copyright (c) 2017-2018 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

const forge = require('node-forge');

const LinkedDataSignature2015 = require('./LinkedDataSignature2015');

module.exports = class EcdsaKoblitzSignature2016 extends LinkedDataSignature2015 {
  constructor({
    privateKeyWif,
    publicKeyWif,
    creator,
    date,
    domain,
    nonce
  } = {}) {
    super({
      type: 'EcdsaKoblitzSignature2016',
      creator,
      date,
      domain,
      nonce
    });
    this.privateKeyWif = privateKeyWif;
    this.publicKeyWif = publicKeyWif;
  }

  sign({
    verifyData,
    proof
  }) {
    var _this = this;

    return _asyncToGenerator(function* () {
      if (typeof _this.privateKeyWif !== 'string') {
        throw new TypeError('"privateKeyWif" must be a base58 formatted string.');
      }

      const bitcoreMessage = require('bitcore-message');

      const bitcore = bitcoreMessage.Bitcore;
      const privateKey = bitcore.PrivateKey.fromWIF(_this.privateKeyWif);
      const message = bitcoreMessage(forge.util.binary.raw.encode(verifyData));
      proof.signatureValue = message.sign(privateKey);
      return proof;
    })();
  }

  verifySignature({
    verifyData,
    proof
  }) {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      const bitcoreMessage = require('bitcore-message');

      const message = bitcoreMessage(forge.util.binary.raw.encode(verifyData));
      return message.verify(_this2.publicKeyWif, proof.signatureValue);
    })();
  }

  getVerificationMethod({
    proof,
    documentLoader
  }) {
    var _this3 = this,
        _superprop_callGetVerificationMethod = (..._args) => super.getVerificationMethod(..._args);

    return _asyncToGenerator(function* () {
      const verificationMethod = yield _superprop_callGetVerificationMethod({
        proof,
        documentLoader
      });

      if (typeof verificationMethod.publicKeyWif !== 'string') {
        throw new TypeError('Unknown public key encoding. Public key encoding must be ' + '"publicKeyWif".');
      }

      if (!_this3.publicKeyWif) {
        _this3.publicKeyWif = verificationMethod.publicKeyWif;
      }

      return verificationMethod;
    })();
  }

};