/*!
 * Copyright (c) 2017-2018 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

const constants = require('../constants');

const jsonld = require('jsonld');

const util = require('../util');

const LinkedDataProof = require('./LinkedDataProof');

module.exports = class LinkedDataSignature extends LinkedDataProof {
  /**
   * @param type {string} Provided by subclass.
   *
   * One of these parameters is required to use a suite for signing:
   *
   * @param [creator] {string} A key id URL to the paired public key.
   * @param [verificationMethod] {string} A key id URL to the paired public key.
   *
   * Advanced optional parameters and overrides:
   *
   * @param [proof] {object} a JSON-LD document with options to use for
   *   the `proof` node (e.g. any other custom fields can be provided here
   *   using a context different from security-v2).
   * @param [date] {string|Date} signing date to use if not passed.
   */
  constructor({
    type,
    creator,
    verificationMethod,
    proof,
    date
  } = {}) {
    // validate common options
    if (verificationMethod !== undefined && typeof verificationMethod !== 'string') {
      throw new TypeError('"verificationMethod" must be a URL string.');
    }

    super({
      type
    });
    this.creator = creator;
    this.verificationMethod = verificationMethod;
    this.proof = proof;

    if (date !== undefined) {
      this.date = new Date(date);

      if (isNaN(this.date)) {
        throw TypeError(`"date" "${date}" is not a valid date.`);
      }
    }
  }
  /**
   * @param document {object} to be signed.
   * @param purpose {ProofPurpose}
   * @param documentLoader {function}
   * @param expansionMap {function}
   * @param compactProof {boolean}
   *
   * @returns {Promise<object>} Resolves with the created proof object.
   */


  createProof({
    document,
    purpose,
    documentLoader,
    expansionMap,
    compactProof
  }) {
    var _this = this;

    return _asyncToGenerator(function* () {
      // build proof (currently known as `signature options` in spec)
      let proof;

      if (_this.proof) {
        // use proof JSON-LD document passed to API
        proof = yield jsonld.compact(_this.proof, constants.SECURITY_CONTEXT_URL, {
          documentLoader,
          expansionMap,
          compactToRelative: false
        });
      } else {
        // create proof JSON-LD document
        proof = {
          '@context': constants.SECURITY_CONTEXT_URL
        };
      } // ensure proof type is set


      proof.type = _this.type; // set default `now` date if not given in `proof` or `options`

      let date = _this.date;

      if (proof.created === undefined && date === undefined) {
        date = new Date();
      } // ensure date is in string format


      if (date !== undefined && typeof date !== 'string') {
        date = util.w3cDate(date);
      } // add API overrides


      if (date !== undefined) {
        proof.created = date;
      } // `verificationMethod` is for newer suites, `creator` for legacy


      if (_this.verificationMethod !== undefined) {
        proof.verificationMethod = _this.verificationMethod;
      }

      if (_this.creator !== undefined) {
        proof.creator = _this.creator;
      } // add any extensions to proof (mostly for legacy support)


      proof = yield _this.updateProof({
        document,
        proof,
        purpose,
        documentLoader,
        expansionMap,
        compactProof
      }); // allow purpose to update the proof; the `proof` is in the
      // SECURITY_CONTEXT_URL `@context` -- therefore the `purpose` must
      // ensure any added fields are also represented in that same `@context`

      proof = yield purpose.update(proof, {
        document,
        suite: _this,
        documentLoader,
        expansionMap
      }); // create data to sign

      const verifyData = yield _this.createVerifyData({
        document,
        proof,
        documentLoader,
        expansionMap,
        compactProof
      }); // sign data

      proof = yield _this.sign({
        verifyData,
        document,
        proof,
        documentLoader,
        expansionMap
      });
      return proof;
    })();
  }
  /**
   * @param document {object} to be signed.
   * @param purpose {ProofPurpose}
   * @param documentLoader {function}
   * @param expansionMap {function}
   * @param compactProof {boolean}
   *
   * @returns {Promise<object>} Resolves with the created proof object.
   */


  updateProof({
    proof
  }) {
    return _asyncToGenerator(function* () {
      // extending classes may do more
      return proof;
    })();
  }
  /**
   * @param proof {object} the proof to be verified.
   * @param document {object} the document the proof applies to.
   * @param purpose {ProofPurpose}
   * @param documentLoader {function}
   * @param expansionMap {function}
   * @param compactProof {boolean}
   *
   * @returns {Promise<{object}>} Resolves with the verification result.
   */


  verifyProof({
    proof,
    document,
    purpose,
    documentLoader,
    expansionMap,
    compactProof
  }) {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      try {
        // create data to verify
        const verifyData = yield _this2.createVerifyData({
          document,
          proof,
          documentLoader,
          expansionMap,
          compactProof
        }); // fetch verification method

        const verificationMethod = yield _this2.getVerificationMethod({
          proof,
          document,
          documentLoader,
          expansionMap
        }); // verify signature on data

        const verified = yield _this2.verifySignature({
          verifyData,
          verificationMethod,
          document,
          proof,
          documentLoader,
          expansionMap
        });

        if (!verified) {
          throw new Error('Invalid signature.');
        } // ensure proof was performed for a valid purpose


        const {
          valid,
          error
        } = yield purpose.validate(proof, {
          document,
          suite: _this2,
          verificationMethod,
          documentLoader,
          expansionMap
        });

        if (!valid) {
          throw error;
        }

        return {
          verified: true
        };
      } catch (error) {
        return {
          verified: false,
          error
        };
      }
    })();
  }

  canonize(input, {
    documentLoader,
    expansionMap,
    skipExpansion
  }) {
    return _asyncToGenerator(function* () {
      return jsonld.canonize(input, {
        algorithm: 'URDNA2015',
        format: 'application/n-quads',
        documentLoader,
        expansionMap,
        skipExpansion
      });
    })();
  }

  canonizeProof(proof, {
    documentLoader,
    expansionMap
  }) {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      // `jws`,`signatureValue`,`proofValue` must not be included in the proof
      // options
      proof = _objectSpread({}, proof);
      delete proof.jws;
      delete proof.signatureValue;
      delete proof.proofValue;
      return _this3.canonize(proof, {
        documentLoader,
        expansionMap,
        skipExpansion: false
      });
    })();
  }
  /**
   * @param document {object} to be signed/verified.
   * @param proof {object}
   * @param documentLoader {function}
   * @param expansionMap {function}
   * @param compactProof {boolean}
   *
   * @returns {Promise<{Uint8Array}>}.
   */


  createVerifyData({
    document,
    proof,
    documentLoader,
    expansionMap
  }) {
    var _this4 = this;

    return _asyncToGenerator(function* () {
      // concatenate hash of c14n proof options and hash of c14n document
      const c14nProofOptions = yield _this4.canonizeProof(proof, {
        documentLoader,
        expansionMap
      });
      const c14nDocument = yield _this4.canonize(document, {
        documentLoader,
        expansionMap
      });
      return util.concat(util.sha256(c14nProofOptions), util.sha256(c14nDocument));
    })();
  }
  /**
   * @param document {object} to be signed.
   * @param proof {object}
   * @param documentLoader {function}
   * @param expansionMap {function}
   */


  getVerificationMethod({
    proof,
    documentLoader
  }) {
    return _asyncToGenerator(function* () {
      let {
        verificationMethod
      } = proof;

      if (!verificationMethod) {
        // backwards compatibility support for `creator`
        const {
          creator
        } = proof;
        verificationMethod = creator;
      }

      if (typeof verificationMethod === 'object') {
        verificationMethod = verificationMethod.id;
      }

      if (!verificationMethod) {
        throw new Error('No "verificationMethod" or "creator" found in proof.');
      } // Note: `expansionMap` is intentionally not passed; we can safely drop
      // properties here and must allow for it


      const {
        '@graph': [framed]
      } = yield jsonld.frame(verificationMethod, {
        '@context': constants.SECURITY_CONTEXT_URL,
        '@embed': '@always',
        id: verificationMethod
      }, {
        documentLoader,
        compactToRelative: false
      });

      if (!framed) {
        throw new Error(`Verification method ${verificationMethod} not found.`);
      } // ensure verification method has not been revoked


      if (framed.revoked !== undefined) {
        throw new Error('The verification method has been revoked.');
      }

      return framed;
    })();
  }
  /**
   * @param verifyData {Uint8Array}.
   * @param document {object} to be signed.
   * @param proof {object}
   * @param documentLoader {function}
   * @param expansionMap {function}
   *
   * @returns {Promise<{object}>} the proof containing the signature value.
   */


  sign() {
    return _asyncToGenerator(function* () {
      throw new Error('Must be implemented by a derived class.');
    })();
  }
  /**
   * @param verifyData {Uint8Array}.
   * @param verificationMethod {object}.
   * @param document {object} to be signed.
   * @param proof {object}
   * @param documentLoader {function}
   * @param expansionMap {function}
   *
   * @returns {Promise<boolean>}
   */


  verifySignature() {
    return _asyncToGenerator(function* () {
      throw new Error('Must be implemented by a derived class.');
    })();
  }

};