/*!
 * Copyright (c) 2017-2018 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

const env = require('../env');

const forge = require('node-forge');

const LinkedDataSignature = require('./LinkedDataSignature');

module.exports = class LinkedDataSignature2015 extends LinkedDataSignature {
  /**
   * Advanced optional parameters and overrides:
   *
   * @param [domain] {string} domain to include in the signature.
   * @param [nonce] {string} nonce to include in the signature.
   */
  constructor({
    type = 'LinkedDataSignature2015',
    privateKeyPem,
    publicKeyPem,
    creator,
    date,
    domain,
    nonce
  } = {}) {
    if (domain !== undefined && typeof domain !== 'string') {
      throw new TypeError('"domain" must be a string.');
    }

    if (nonce !== undefined && typeof nonce !== 'string') {
      throw new TypeError('"nonce" must be a string.');
    }

    super({
      type,
      creator,
      date,
      domain,
      nonce
    });
    this.legacy = true;
    this.privateKeyPem = privateKeyPem;
    this.publicKeyPem = publicKeyPem;
    this.nonce = nonce;
    this.domain = domain;
  }
  /**
   * @param document {object} to be signed.
   * @param purpose {ProofPurpose}
   * @param documentLoader {function}
   * @param expansionMap {function}
   * @param compactProof {boolean}
   *
   * @returns {Promise<object>} Resolves with the created proof object.
   */


  updateProof({
    proof
  }) {
    var _this = this;

    return _asyncToGenerator(function* () {
      if (_this.domain !== undefined) {
        proof.domain = _this.domain;
      }

      if (_this.nonce !== undefined) {
        proof.nonce = _this.nonce;
      }

      return proof;
    })();
  }
  /**
   * @param proof {object} the proof to be verified.
   * @param document {object} the document the proof applies to.
   * @param purpose {ProofPurpose}
   * @param documentLoader {function}
   * @param expansionMap {function}
   * @param compactProof {boolean}
   *
   * @returns {Promise<{object}>} Resolves with the verification result.
   */


  verifyProof({
    proof,
    document,
    purpose,
    documentLoader,
    expansionMap,
    compactProof
  }) {
    var _this2 = this,
        _superprop_callVerifyProof = (..._args) => super.verifyProof(..._args);

    return _asyncToGenerator(function* () {
      try {
        // check domain
        if (_this2.domain !== undefined && proof.domain !== _this2.domain) {
          throw new Error('The domain is not as expected; ' + `domain="${proof.domain}", expected="${_this2.domain}"`);
        }

        return _superprop_callVerifyProof({
          proof,
          document,
          purpose,
          documentLoader,
          expansionMap,
          compactProof
        });
      } catch (error) {
        return {
          verified: false,
          error
        };
      }
    })();
  }
  /**
   * @param document {object} to be signed/verified.
   * @param proof {object}
   * @param documentLoader {function}
   * @param expansionMap {function}
   * @param compactProof {boolean}
   *
   * @returns {Promise<{Uint8Array}>}.
   */


  createVerifyData({
    document,
    proof,
    documentLoader,
    expansionMap
  }) {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      const c14n = yield _this3.canonize(document, {
        documentLoader,
        expansionMap
      });
      let verifyData = '';
      const headers = {
        'http://purl.org/dc/elements/1.1/created': proof.created,
        'https://w3id.org/security#domain': proof.domain,
        'https://w3id.org/security#nonce': proof.nonce
      }; // add headers in lexicographical order

      const keys = Object.keys(headers).sort();

      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        const value = headers[key];

        if (!(value === null || value === undefined)) {
          verifyData += key + ': ' + value + '\n';
        }
      }

      verifyData += c14n;
      const buffer = new forge.util.ByteBuffer(verifyData, 'utf8');
      return forge.util.binary.raw.decode(buffer.getBytes());
    })();
  }

  sign({
    verifyData,
    proof
  }) {
    var _this4 = this;

    return _asyncToGenerator(function* () {
      const {
        privateKeyPem
      } = _this4;

      if (typeof privateKeyPem !== 'string') {
        throw new TypeError('"privateKeyPem" must be a PEM formatted string.');
      }

      let signature;

      if (env.nodejs) {
        // optimize using node libraries
        const crypto = require('crypto');

        const signer = crypto.createSign('RSA-SHA256');
        signer.update(Buffer.from(verifyData.buffer, verifyData.byteOffset, verifyData.length));
        signature = signer.sign(privateKeyPem, 'base64');
      } else {
        // browser or other environment
        const privateKey = forge.pki.privateKeyFromPem(privateKeyPem);
        const md = forge.md.sha256.create();
        md.update(forge.util.binary.raw.encode(verifyData), 'binary');
        signature = forge.util.encode64(privateKey.sign(md));
      }

      proof.signatureValue = signature;
      return proof;
    })();
  }

  verifySignature({
    verifyData,
    proof
  }) {
    var _this5 = this;

    return _asyncToGenerator(function* () {
      const {
        publicKeyPem
      } = _this5;

      if (typeof publicKeyPem !== 'string') {
        throw new TypeError('Could not verify signature; invalid "publicKeyPem".');
      }

      if (env.nodejs) {
        // optimize using node libraries
        const crypto = require('crypto');

        const verifier = crypto.createVerify('RSA-SHA256');
        verifier.update(Buffer.from(verifyData.buffer, verifyData.byteOffset, verifyData.length));
        return verifier.verify(publicKeyPem, proof.signatureValue, 'base64');
      } // browser or other environment


      const publicKey = forge.pki.publicKeyFromPem(publicKeyPem);
      const md = forge.md.sha256.create();
      md.update(forge.util.binary.raw.encode(verifyData), 'binary');

      try {
        return publicKey.verify(md.digest().bytes(), forge.util.decode64(proof.signatureValue));
      } catch (e) {
        // simply return false, do return information about malformed signature
        return false;
      }
    })();
  }

  getVerificationMethod({
    proof,
    documentLoader
  }) {
    var _this6 = this,
        _superprop_callGetVerificationMethod = (..._args2) => super.getVerificationMethod(..._args2);

    return _asyncToGenerator(function* () {
      const verificationMethod = yield _superprop_callGetVerificationMethod({
        proof,
        documentLoader
      });

      if (!_this6.publicKeyPem) {
        _this6.publicKeyPem = verificationMethod.publicKeyPem;
      }

      return verificationMethod;
    })();
  }

};