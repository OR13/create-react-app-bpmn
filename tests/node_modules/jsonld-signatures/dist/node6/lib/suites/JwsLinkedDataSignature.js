/*!
 * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

const LinkedDataSignature = require('./LinkedDataSignature');

const jsonld = require('jsonld');

const util = require('../util');

module.exports = class JwsLinkedDataSignature extends LinkedDataSignature {
  /**
   * @param type {string} Provided by subclass.
   * @param alg {string} JWS alg provided by subclass.
   * @param [LDKeyClass] {LDKeyClass} provided by subclass or subclass
   *   overrides `getVerificationMethod`.
   *
   * One of these parameters is required to use a suite for signing:
   *
   * @param [creator] {string} A key id URL to the paired public key.
   * @param [verificationMethod] {string} A key id URL to the paired public key.
   *
   * This parameter is required for signing:
   *
   * @param [signer] {function} an optional signer.
   *
   * Advanced optional parameters and overrides:
   *
   * @param [proof] {object} a JSON-LD document with options to use for
   *   the `proof` node (e.g. any other custom fields can be provided here
   *   using a context different from security-v2).
   * @param [date] {string|Date} signing date to use if not passed.
   * @param [key] {LDKeyPair} an optional crypto-ld KeyPair.
   */
  constructor({
    type,
    alg,
    LDKeyClass,
    creator,
    verificationMethod,
    signer,
    key,
    proof,
    date
  } = {}) {
    super({
      type,
      creator,
      verificationMethod,
      proof,
      date
    });
    this.alg = alg;
    this.LDKeyClass = LDKeyClass;
    this.signer = signer;

    if (key) {
      if (verificationMethod === undefined && creator === undefined) {
        const publicKey = key.publicNode();

        if (publicKey.controller) {
          // assume newer signature terms
          this.verificationMethod = publicKey.id;
        } else {
          // assume legacy signature terms
          this.creator = publicKey.id;
        }
      }

      this.key = key;
      this.signer = key.signer();
      this.verifier = key.verifier();
    }
  }
  /**
   * @param verifyData {Uint8Array}.
   * @param proof {object}
   *
   * @returns {Promise<{object}>} the proof containing the signature value.
   */


  sign({
    verifyData,
    proof
  }) {
    var _this = this;

    return _asyncToGenerator(function* () {
      // JWS header
      const header = {
        alg: _this.alg,
        b64: false,
        crit: ['b64']
      };
      /*
      +-------+-----------------------------------------------------------+
      | "b64" | JWS Signing Input Formula                                 |
      +-------+-----------------------------------------------------------+
      | true  | ASCII(BASE64URL(UTF8(JWS Protected Header)) || '.' ||     |
      |       | BASE64URL(JWS Payload))                                   |
      |       |                                                           |
      | false | ASCII(BASE64URL(UTF8(JWS Protected Header)) || '.') ||    |
      |       | JWS Payload                                               |
      +-------+-----------------------------------------------------------+
      */
      // create JWS data and sign

      const encodedHeader = util.encodeBase64Url(JSON.stringify(header));
      const data = util.createJws({
        encodedHeader,
        verifyData
      });
      const signature = yield _this.signer.sign({
        data
      }); // create detached content signature

      const encodedSignature = util.encodeBase64Url(signature);
      proof.jws = encodedHeader + '..' + encodedSignature;
      return proof;
    })();
  }
  /**
   * @param verifyData {Uint8Array}.
   * @param verificationMethod {object}.
   * @param document {object} the document the proof applies to.
   * @param proof {object} the proof to be verified.
   * @param purpose {ProofPurpose}
   * @param documentLoader {function}
   * @param expansionMap {function}
   *
   * @returns {Promise<{boolean}>} Resolves with the verification result.
   */


  verifySignature({
    verifyData,
    verificationMethod,
    proof
  }) {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      // add payload into detached content signature
      const [encodedHeader,,
      /*payload*/
      encodedSignature] = proof.jws.split('.');
      let header;

      try {
        header = JSON.parse(util.decodeBase64UrlToString(encodedHeader));
      } catch (e) {
        throw new Error('Could not parse JWS header; ' + e);
      }

      if (!(header && typeof header === 'object')) {
        throw new Error('Invalid JWS header.');
      } // confirm header matches all expectations


      if (!(header.alg === _this2.alg && header.b64 === false && Array.isArray(header.crit) && header.crit.length === 1 && header.crit[0] === 'b64') && Object.keys(header).length === 3) {
        throw new Error(`Invalid JWS header parameters for ${_this2.type}.`);
      } // do signature verification


      const signature = util.decodeBase64Url(encodedSignature);
      const data = util.createJws({
        encodedHeader,
        verifyData
      });
      let {
        verifier
      } = _this2;

      if (!verifier) {
        const key = yield _this2.LDKeyClass.from(verificationMethod);
        verifier = key.verifier();
      }

      return verifier.verify({
        data,
        signature
      });
    })();
  }

  assertVerificationMethod({
    verificationMethod
  }) {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      if (!jsonld.hasValue(verificationMethod, 'type', _this3.requiredKeyType)) {
        throw new Error(`Invalid key type. Key type must be "${_this3.requiredKeyType}".`);
      }
    })();
  }

  getVerificationMethod({
    proof,
    documentLoader
  }) {
    var _this4 = this,
        _superprop_callGetVerificationMethod = (..._args) => super.getVerificationMethod(..._args);

    return _asyncToGenerator(function* () {
      if (_this4.key) {
        return _this4.key.publicNode();
      }

      const verificationMethod = yield _superprop_callGetVerificationMethod({
        proof,
        documentLoader
      });
      yield _this4.assertVerificationMethod({
        verificationMethod
      });
      return verificationMethod;
    })();
  }

  matchProof({
    proof,
    document,
    purpose,
    documentLoader,
    expansionMap
  }) {
    var _this5 = this,
        _superprop_callMatchProof = (..._args2) => super.matchProof(..._args2);

    return _asyncToGenerator(function* () {
      if (!(yield _superprop_callMatchProof({
        proof,
        document,
        purpose,
        documentLoader,
        expansionMap
      }))) {
        return false;
      }

      if (!_this5.key) {
        // no key specified, so assume this suite matches and it can be retrieved
        return true;
      }

      let {
        verificationMethod
      } = proof;

      if (!verificationMethod) {
        verificationMethod = proof.creator;
      } // only match if the key specified matches the one in the proof


      if (typeof verificationMethod === 'object') {
        return verificationMethod.id === _this5.key.id;
      }

      return verificationMethod === _this5.key.id;
    })();
  }

};