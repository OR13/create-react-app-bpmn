{"version":3,"file":"jsonld-signatures.min.js","sources":["webpack://[name]/webpack/universalModuleDefinition","webpack://[name]/./lib/constants.js","webpack://[name]/./lib/purposes/ControllerProofPurpose.js","webpack://[name]/./lib/suites/LinkedDataSignature2015.js","webpack://[name]/./lib/env.js","webpack://[name]/./lib/suites/LinkedDataSignature.js","webpack://[name]/./lib/LDKeyPair.js","webpack://[name]/./lib/documentLoader.js","webpack://[name]/./lib/purposes/PublicKeyProofPurpose.js","webpack://[name]/./lib/purposes/ProofPurpose.js","webpack://[name]/./lib/suites/LinkedDataProof.js","webpack://[name]/./lib/suites/JwsLinkedDataSignature.js","webpack://[name]/./lib/jsonld-signatures.js","webpack://[name]/./lib/ProofSet.js","webpack://[name]/./lib/expansionMap.js","webpack://[name]/./lib/suites.js","webpack://[name]/./lib/suites/EcdsaKoblitzSignature2016.js","webpack://[name]/./lib/suites/Ed25519Signature2018.js","webpack://[name]/./lib/suites/GraphSignature2012.js","webpack://[name]/./lib/suites/RsaSignature2018.js","webpack://[name]/./lib/purposes.js","webpack://[name]/./lib/purposes/AssertionProofPurpose.js","webpack://[name]/./lib/purposes/AuthenticationProofPurpose.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"jsonld\"), require(\"forge\"), require(\"bitcoreMessage\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"jsonld\", \"forge\", \"bitcoreMessage\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"jsonld-signatures\"] = factory(require(\"jsonld\"), require(\"forge\"), require(\"bitcoreMessage\"));\n\telse\n\t\troot[\"jsonld-signatures\"] = factory(root[\"jsonld\"], root[\"forge\"], root[\"bitcoreMessage\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE__19__, __WEBPACK_EXTERNAL_MODULE__21__, __WEBPACK_EXTERNAL_MODULE__68__) {\nreturn ","/*!\n * Copyright (c) 2017-2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nmodule.exports = {\n  SECURITY_CONTEXT_URL: 'https://w3id.org/security/v2',\n  SECURITY_CONTEXT_V1_URL: 'https://w3id.org/security/v1',\n  SECURITY_CONTEXT_V2_URL: 'https://w3id.org/security/v2',\n  SECURITY_PROOF_URL: 'https://w3id.org/security#proof',\n  SECURITY_SIGNATURE_URL: 'https://w3id.org/security#signature'\n};\n","/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst constants = require('../constants');\nconst jsonld = require('jsonld');\nconst ProofPurpose = require('./ProofPurpose');\n\nmodule.exports = class ControllerProofPurpose extends ProofPurpose {\n  /**\n   * Creates a proof purpose that will validate whether or not the verification\n   * method in a proof was authorized by its declared controller for the\n   * proof's purpose.\n   *\n   * @param term {string} the `proofPurpose` term, as defined in the\n   *    SECURITY_CONTEXT_URL `@context` or a URI if not defined in such.\n   * @param [controller] {object} the description of the controller, if it\n   *   is not to be dereferenced via a `documentLoader`.\n   * @param [date] {string or Date or integer} the expected date for\n   *   the creation of the proof.\n   * @param [maxTimestampDelta] {integer} a maximum number of seconds that\n   *   the date on the signature can deviate from, defaults to `Infinity`.\n   */\n  constructor({term, controller, date, maxTimestampDelta = Infinity} = {}) {\n    super({term, date, maxTimestampDelta});\n    if(controller !== undefined) {\n      if(typeof controller !== 'object') {\n        throw new TypeError('\"controller\" must be an object.');\n      }\n      this.controller = controller;\n    }\n  }\n\n  async validate(proof, {verificationMethod, documentLoader, expansionMap}) {\n    try {\n      const result = await super.validate(\n        proof, {verificationMethod, documentLoader, expansionMap});\n      if(!result.valid) {\n        throw result.error;\n      }\n\n      const {id: verificationId} = verificationMethod;\n\n      // if no `controller` specified, use verification method's\n      if(this.controller) {\n        result.controller = this.controller;\n      } else {\n        // support legacy `owner` property\n        const {controller, owner} = verificationMethod;\n        let controllerId;\n        if(controller) {\n          if(typeof controller === 'object') {\n            controllerId = controller.id;\n          } else if(typeof controller !== 'string') {\n            throw new TypeError(\n              '\"controller\" must be a string representing a URL.');\n          }\n          controllerId = controller;\n        } else if(owner) {\n          if(typeof owner === 'object') {\n            controllerId = owner.id;\n          } else if(typeof owner !== 'string') {\n            throw new TypeError(\n              '\"owner\" must be a string representing a URL.');\n          }\n          controllerId = owner;\n        }\n\n        // Note: `expansionMap` is intentionally not passed; we can safely drop\n        // properties here and must allow for it\n        const {'@graph': [framed = {}]} = await jsonld.frame(controllerId, {\n          '@context': constants.SECURITY_CONTEXT_URL,\n          id: controllerId,\n          [this.term]: {\n            '@embed': '@never',\n            id: verificationId\n          }\n        }, {documentLoader, compactToRelative: false});\n        result.controller = framed;\n      }\n\n      const verificationMethods = jsonld.getValues(\n        result.controller, this.term);\n      result.valid = verificationMethods.some(vm =>\n        vm === verificationId ||\n        (typeof vm === 'object' && vm.id === verificationId));\n      if(!result.valid) {\n        throw new Error(\n          `Verification method \"${verificationMethod.id}\" not authorized ` +\n          `by controller for proof purpose \"${this.term}\".`);\n      }\n      return result;\n    } catch(error) {\n      return {valid: false, error};\n    }\n  }\n};\n","/*!\n * Copyright (c) 2017-2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst env = require('../env');\nconst forge = require('node-forge');\nconst LinkedDataSignature = require('./LinkedDataSignature');\n\nmodule.exports = class LinkedDataSignature2015 extends LinkedDataSignature {\n  /**\n   * Advanced optional parameters and overrides:\n   *\n   * @param [domain] {string} domain to include in the signature.\n   * @param [nonce] {string} nonce to include in the signature.\n   */\n  constructor({\n    type = 'LinkedDataSignature2015',\n    privateKeyPem, publicKeyPem, creator, date, domain, nonce} = {}) {\n    if(domain !== undefined && typeof domain !== 'string') {\n      throw new TypeError('\"domain\" must be a string.');\n    }\n    if(nonce !== undefined && typeof nonce !== 'string') {\n      throw new TypeError('\"nonce\" must be a string.');\n    }\n    super({type, creator, date, domain, nonce});\n    this.legacy = true;\n    this.privateKeyPem = privateKeyPem;\n    this.publicKeyPem = publicKeyPem;\n    this.nonce = nonce;\n    this.domain = domain;\n  }\n\n  /**\n   * @param document {object} to be signed.\n   * @param purpose {ProofPurpose}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   * @param compactProof {boolean}\n   *\n   * @returns {Promise<object>} Resolves with the created proof object.\n   */\n  async updateProof({proof}) {\n    if(this.domain !== undefined) {\n      proof.domain = this.domain;\n    }\n    if(this.nonce !== undefined) {\n      proof.nonce = this.nonce;\n    }\n    return proof;\n  }\n\n  /**\n   * @param proof {object} the proof to be verified.\n   * @param document {object} the document the proof applies to.\n   * @param purpose {ProofPurpose}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   * @param compactProof {boolean}\n   *\n   * @returns {Promise<{object}>} Resolves with the verification result.\n   */\n  async verifyProof({\n    proof, document, purpose, documentLoader, expansionMap,\n    compactProof}) {\n    try {\n      // check domain\n      if(this.domain !== undefined && proof.domain !== this.domain) {\n        throw new Error('The domain is not as expected; ' +\n          `domain=\"${proof.domain}\", expected=\"${this.domain}\"`);\n      }\n\n      return super.verifyProof({\n        proof, document, purpose, documentLoader, expansionMap,\n        compactProof});\n    } catch(error) {\n      return {verified: false, error};\n    }\n  }\n\n  /**\n   * @param document {object} to be signed/verified.\n   * @param proof {object}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   * @param compactProof {boolean}\n   *\n   * @returns {Promise<{Uint8Array}>}.\n   */\n  async createVerifyData({\n    document, proof, documentLoader, expansionMap}) {\n    const c14n = await this.canonize(document, {\n      documentLoader,\n      expansionMap\n    });\n\n    let verifyData = '';\n    const headers = {\n      'http://purl.org/dc/elements/1.1/created': proof.created,\n      'https://w3id.org/security#domain': proof.domain,\n      'https://w3id.org/security#nonce': proof.nonce\n    };\n    // add headers in lexicographical order\n    const keys = Object.keys(headers).sort();\n    for(let i = 0; i < keys.length; ++i) {\n      const key = keys[i];\n      const value = headers[key];\n      if(!(value === null || value === undefined)) {\n        verifyData += key + ': ' + value + '\\n';\n      }\n    }\n    verifyData += c14n;\n    const buffer = new forge.util.ByteBuffer(verifyData, 'utf8');\n    return forge.util.binary.raw.decode(buffer.getBytes());\n  }\n\n  async sign({verifyData, proof}) {\n    const {privateKeyPem} = this;\n    if(typeof privateKeyPem !== 'string') {\n      throw new TypeError('\"privateKeyPem\" must be a PEM formatted string.');\n    }\n\n    let signature;\n    if(env.nodejs) {\n      // optimize using node libraries\n      const crypto = require('crypto');\n      const signer = crypto.createSign('RSA-SHA256');\n      signer.update(Buffer.from(\n        verifyData.buffer, verifyData.byteOffset, verifyData.length));\n      signature = signer.sign(privateKeyPem, 'base64');\n    } else {\n      // browser or other environment\n      const privateKey = forge.pki.privateKeyFromPem(privateKeyPem);\n      const md = forge.md.sha256.create();\n      md.update(forge.util.binary.raw.encode(verifyData), 'binary');\n      signature = forge.util.encode64(privateKey.sign(md));\n    }\n\n    proof.signatureValue = signature;\n    return proof;\n  }\n\n  async verifySignature({verifyData, proof}) {\n    const {publicKeyPem} = this;\n    if(typeof publicKeyPem !== 'string') {\n      throw new TypeError(\n        'Could not verify signature; invalid \"publicKeyPem\".');\n    }\n\n    if(env.nodejs) {\n      // optimize using node libraries\n      const crypto = require('crypto');\n      const verifier = crypto.createVerify('RSA-SHA256');\n      verifier.update(Buffer.from(\n        verifyData.buffer, verifyData.byteOffset, verifyData.length));\n      return verifier.verify(publicKeyPem, proof.signatureValue, 'base64');\n    }\n\n    // browser or other environment\n    const publicKey = forge.pki.publicKeyFromPem(publicKeyPem);\n    const md = forge.md.sha256.create();\n    md.update(forge.util.binary.raw.encode(verifyData), 'binary');\n    try {\n      return publicKey.verify(\n        md.digest().bytes(), forge.util.decode64(proof.signatureValue));\n    } catch(e) {\n      // simply return false, do return information about malformed signature\n      return false;\n    }\n  }\n\n  async getVerificationMethod({proof, documentLoader}) {\n    const verificationMethod = await super.getVerificationMethod(\n      {proof, documentLoader});\n    if(!this.publicKeyPem) {\n      this.publicKeyPem = verificationMethod.publicKeyPem;\n    }\n    return verificationMethod;\n  }\n};\n","/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\n// determine if using node.js or browser\nconst nodejs = (\n  typeof process !== 'undefined' && process.versions && process.versions.node);\nconst browser = !nodejs &&\n  (typeof window !== 'undefined' || typeof self !== 'undefined');\n\nmodule.exports = {\n  nodejs,\n  browser\n};\n","/*!\n * Copyright (c) 2017-2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst constants = require('../constants');\nconst jsonld = require('jsonld');\nconst util = require('../util');\nconst LinkedDataProof = require('./LinkedDataProof');\n\nmodule.exports = class LinkedDataSignature extends LinkedDataProof {\n  /**\n   * @param type {string} Provided by subclass.\n   *\n   * One of these parameters is required to use a suite for signing:\n   *\n   * @param [creator] {string} A key id URL to the paired public key.\n   * @param [verificationMethod] {string} A key id URL to the paired public key.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param [proof] {object} a JSON-LD document with options to use for\n   *   the `proof` node (e.g. any other custom fields can be provided here\n   *   using a context different from security-v2).\n   * @param [date] {string|Date} signing date to use if not passed.\n   */\n  constructor({\n    type, creator, verificationMethod, proof, date} = {}) {\n    // validate common options\n    if(verificationMethod !== undefined &&\n      typeof verificationMethod !== 'string') {\n      throw new TypeError('\"verificationMethod\" must be a URL string.');\n    }\n    super({type});\n    this.creator = creator;\n    this.verificationMethod = verificationMethod;\n    this.proof = proof;\n    if(date !== undefined) {\n      this.date = new Date(date);\n      if(isNaN(this.date)) {\n        throw TypeError(`\"date\" \"${date}\" is not a valid date.`);\n      }\n    }\n  }\n\n  /**\n   * @param document {object} to be signed.\n   * @param purpose {ProofPurpose}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   * @param compactProof {boolean}\n   *\n   * @returns {Promise<object>} Resolves with the created proof object.\n   */\n  async createProof(\n    {document, purpose, documentLoader, expansionMap, compactProof}) {\n    // build proof (currently known as `signature options` in spec)\n    let proof;\n    if(this.proof) {\n      // use proof JSON-LD document passed to API\n      proof = await jsonld.compact(\n        this.proof, constants.SECURITY_CONTEXT_URL,\n        {documentLoader, expansionMap, compactToRelative: false});\n    } else {\n      // create proof JSON-LD document\n      proof = {'@context': constants.SECURITY_CONTEXT_URL};\n    }\n\n    // ensure proof type is set\n    proof.type = this.type;\n\n    // set default `now` date if not given in `proof` or `options`\n    let date = this.date;\n    if(proof.created === undefined && date === undefined) {\n      date = new Date();\n    }\n\n    // ensure date is in string format\n    if(date !== undefined && typeof date !== 'string') {\n      date = util.w3cDate(date);\n    }\n\n    // add API overrides\n    if(date !== undefined) {\n      proof.created = date;\n    }\n    // `verificationMethod` is for newer suites, `creator` for legacy\n    if(this.verificationMethod !== undefined) {\n      proof.verificationMethod = this.verificationMethod;\n    }\n    if(this.creator !== undefined) {\n      proof.creator = this.creator;\n    }\n\n    // add any extensions to proof (mostly for legacy support)\n    proof = await this.updateProof({\n      document, proof, purpose,\n      documentLoader, expansionMap, compactProof});\n\n    // allow purpose to update the proof; the `proof` is in the\n    // SECURITY_CONTEXT_URL `@context` -- therefore the `purpose` must\n    // ensure any added fields are also represented in that same `@context`\n    proof = await purpose.update(\n      proof, {document, suite: this, documentLoader, expansionMap});\n\n    // create data to sign\n    const verifyData = await this.createVerifyData(\n      {document, proof, documentLoader, expansionMap, compactProof});\n\n    // sign data\n    proof = await this.sign(\n      {verifyData, document, proof, documentLoader, expansionMap});\n\n    return proof;\n  }\n\n  /**\n   * @param document {object} to be signed.\n   * @param purpose {ProofPurpose}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   * @param compactProof {boolean}\n   *\n   * @returns {Promise<object>} Resolves with the created proof object.\n   */\n  async updateProof({proof}) {\n    // extending classes may do more\n    return proof;\n  }\n\n  /**\n   * @param proof {object} the proof to be verified.\n   * @param document {object} the document the proof applies to.\n   * @param purpose {ProofPurpose}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   * @param compactProof {boolean}\n   *\n   * @returns {Promise<{object}>} Resolves with the verification result.\n   */\n  async verifyProof({\n    proof, document, purpose, documentLoader, expansionMap,\n    compactProof}) {\n    try {\n      // create data to verify\n      const verifyData = await this.createVerifyData(\n        {document, proof, documentLoader, expansionMap, compactProof});\n\n      // fetch verification method\n      const verificationMethod = await this.getVerificationMethod(\n        {proof, document, documentLoader, expansionMap});\n\n      // verify signature on data\n      const verified = await this.verifySignature({\n        verifyData, verificationMethod, document, proof,\n        documentLoader, expansionMap});\n      if(!verified) {\n        throw new Error('Invalid signature.');\n      }\n\n      // ensure proof was performed for a valid purpose\n      const {valid, error} = await purpose.validate(\n        proof, {document, suite: this, verificationMethod,\n          documentLoader, expansionMap});\n      if(!valid) {\n        throw error;\n      }\n\n      return {verified: true};\n    } catch(error) {\n      return {verified: false, error};\n    }\n  }\n\n  async canonize(input, {documentLoader, expansionMap, skipExpansion}) {\n    return jsonld.canonize(input, {\n      algorithm: 'URDNA2015',\n      format: 'application/n-quads',\n      documentLoader,\n      expansionMap,\n      skipExpansion\n    });\n  }\n\n  async canonizeProof(proof, {documentLoader, expansionMap}) {\n    // `jws`,`signatureValue`,`proofValue` must not be included in the proof\n    // options\n    proof = {...proof};\n    delete proof.jws;\n    delete proof.signatureValue;\n    delete proof.proofValue;\n    return this.canonize(proof, {\n      documentLoader,\n      expansionMap,\n      skipExpansion: false\n    });\n  }\n\n  /**\n   * @param document {object} to be signed/verified.\n   * @param proof {object}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   * @param compactProof {boolean}\n   *\n   * @returns {Promise<{Uint8Array}>}.\n   */\n  async createVerifyData({\n    document, proof, documentLoader, expansionMap}) {\n    // concatenate hash of c14n proof options and hash of c14n document\n    const c14nProofOptions = await this.canonizeProof(\n      proof, {documentLoader, expansionMap});\n    const c14nDocument = await this.canonize(document, {\n      documentLoader,\n      expansionMap\n    });\n    return util.concat(\n      util.sha256(c14nProofOptions),\n      util.sha256(c14nDocument));\n  }\n\n  /**\n   * @param document {object} to be signed.\n   * @param proof {object}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   */\n  async getVerificationMethod({proof, documentLoader}) {\n    let {verificationMethod} = proof;\n\n    if(!verificationMethod) {\n      // backwards compatibility support for `creator`\n      const {creator} = proof;\n      verificationMethod = creator;\n    }\n\n    if(typeof verificationMethod === 'object') {\n      verificationMethod = verificationMethod.id;\n    }\n\n    if(!verificationMethod) {\n      throw new Error('No \"verificationMethod\" or \"creator\" found in proof.');\n    }\n\n    // Note: `expansionMap` is intentionally not passed; we can safely drop\n    // properties here and must allow for it\n    const {'@graph': [framed]} = await jsonld.frame(verificationMethod, {\n      '@context': constants.SECURITY_CONTEXT_URL,\n      '@embed': '@always',\n      id: verificationMethod\n    }, {documentLoader, compactToRelative: false});\n    if(!framed) {\n      throw new Error(`Verification method ${verificationMethod} not found.`);\n    }\n\n    // ensure verification method has not been revoked\n    if(framed.revoked !== undefined) {\n      throw new Error('The verification method has been revoked.');\n    }\n\n    return framed;\n  }\n\n  /**\n   * @param verifyData {Uint8Array}.\n   * @param document {object} to be signed.\n   * @param proof {object}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   *\n   * @returns {Promise<{object}>} the proof containing the signature value.\n   */\n  async sign() {\n    throw new Error('Must be implemented by a derived class.');\n  }\n\n  /**\n   * @param verifyData {Uint8Array}.\n   * @param verificationMethod {object}.\n   * @param document {object} to be signed.\n   * @param proof {object}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   *\n   * @returns {Promise<boolean>}\n   */\n  async verifySignature() {\n    throw new Error('Must be implemented by a derived class.');\n  }\n};\n","/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst env = require('./env');\nconst forge = require('node-forge');\n\nclass LDKeyPair {\n  publicNode({controller = this.controller, owner = this.owner} = {}) {\n    const publicNode = {\n      id: this.id,\n      type: this.type\n    };\n    if(controller) {\n      publicNode.controller = controller;\n    }\n    if(owner) {\n      publicNode.owner = owner;\n    }\n    this.addEncodedPublicKey(publicNode);\n    return publicNode;\n  }\n}\n\nclass Ed25519KeyPair extends LDKeyPair {\n  constructor({\n    privateKeyBase58, publicKeyBase58, id, type, controller, owner}) {\n    super();\n    this.privateKeyBase58 = privateKeyBase58;\n    this.publicKeyBase58 = publicKeyBase58;\n    this.id = id;\n    this.type = type;\n    this.controller = controller;\n    this.owner = owner;\n  }\n\n  static async from(data) {\n    const keyPair = new Ed25519KeyPair({\n      publicKeyBase58: data.publicKeyBase58,\n      id: data.id,\n      type: data.type,\n      controller: data.controller,\n      owner: data.owner\n    });\n    return keyPair;\n  }\n\n  addEncodedPublicKey(publicKeyNode) {\n    publicKeyNode.publicKeyBase58 = this.publicKeyBase58;\n    return publicKeyNode;\n  }\n\n  signer() {\n    return ed25519SignerFactory(this);\n  }\n\n  verifier() {\n    return ed25519VerifierFactory(this);\n  }\n}\n\nclass RSAKeyPair extends LDKeyPair {\n  constructor({\n    privateKeyPem, publicKeyPem, id, type, controller, owner}) {\n    super();\n    this.privateKeyPem = privateKeyPem;\n    this.publicKeyPem = publicKeyPem;\n    this.id = id;\n    this.type = type;\n    this.controller = controller;\n    this.owner = owner;\n  }\n\n  static async from(data) {\n    const keyPair = new RSAKeyPair({\n      publicKeyPem: data.publicKeyPem,\n      id: data.id,\n      type: data.type,\n      controller: data.controller,\n      owner: data.owner\n    });\n    return keyPair;\n  }\n\n  addEncodedPublicKey(publicKeyNode) {\n    publicKeyNode.publicKeyPem = this.publicKeyPem;\n    return publicKeyNode;\n  }\n\n  signer() {\n    return rsaSignerFactory(this);\n  }\n\n  verifier() {\n    return rsaVerifierFactory(this);\n  }\n}\n\nfunction ed25519SignerFactory(key) {\n  if(!key.privateKeyBase58) {\n    return {\n      async sign() {\n        throw new Error('No private key to sign with.');\n      }\n    };\n  }\n\n  if(env.nodejs) {\n    const chloride = require('chloride');\n    const bs58 = require('bs58');\n    const privateKey = bs58.decode(key.privateKeyBase58);\n    return {\n      async sign({data}) {\n        return chloride.crypto_sign_detached(\n          Buffer.from(data.buffer, data.byteOffset, data.length),\n          privateKey);\n      }\n    };\n  }\n  const privateKey = forge.util.binary.base58.decode(key.privateKeyBase58);\n  return {\n    async sign({data}) {\n      return forge.ed25519.sign({message: data, privateKey});\n    }\n  };\n}\n\nfunction ed25519VerifierFactory(key) {\n  if(!key.publicKeyBase58) {\n    return {\n      async verify() {\n        throw new Error('No public key to verify with.');\n      }\n    };\n  }\n\n  if(env.nodejs) {\n    const chloride = require('chloride');\n    const bs58 = require('bs58');\n    const publicKey = bs58.decode(key.publicKeyBase58);\n    return {\n      async verify({data, signature}) {\n        return chloride.crypto_sign_verify_detached(\n          Buffer.from(signature.buffer, signature.byteOffset, signature.length),\n          Buffer.from(data.buffer, data.byteOffset, data.length),\n          publicKey);\n      }\n    };\n  }\n  const publicKey = forge.util.binary.base58.decode(key.publicKeyBase58);\n  return {\n    async verify({data, signature}) {\n      return forge.ed25519.verify({message: data, signature, publicKey});\n    }\n  };\n}\n\nfunction rsaSignerFactory(key) {\n  if(!key.privateKeyPem) {\n    return {\n      async sign() {\n        throw new Error('No private key to sign with.');\n      }\n    };\n  }\n\n  // Note: Per rfc7518, the digest algorithm for PS256 is SHA-256,\n  // https://tools.ietf.org/html/rfc7518\n\n  // sign data using RSASSA-PSS where PSS uses a SHA-256 hash,\n  // a SHA-256 based masking function MGF1, and a 32 byte salt to match\n  // the hash size\n  if(env.nodejs) {\n    // node.js 8+\n    const crypto = require('crypto');\n    if('RSA_PKCS1_PSS_PADDING' in crypto.constants) {\n      return {\n        async sign({data}) {\n          const signer = crypto.createSign('RSA-SHA256');\n          signer.update(Buffer.from(data.buffer, data.byteOffset, data.length));\n          const buffer = signer.sign({\n            key: key.privateKeyPem,\n            padding: crypto.constants.RSA_PKCS1_PSS_PADDING,\n            saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST\n          });\n          return new Uint8Array(\n            buffer.buffer, buffer.byteOffset, buffer.length);\n        }\n      };\n    }\n  }\n\n  // browser or other environment (including node 6.x)\n  const privateKey = forge.pki.privateKeyFromPem(key.privateKeyPem);\n  return {\n    async sign({data}) {\n      const pss = createPss();\n      const md = forge.md.sha256.create();\n      md.update(forge.util.binary.raw.encode(data), 'binary');\n      const binaryString = privateKey.sign(md, pss);\n      return forge.util.binary.raw.decode(binaryString);\n    }\n  };\n}\n\nfunction rsaVerifierFactory(key) {\n  if(!key.publicKeyPem) {\n    return {\n      async verify() {\n        throw new Error('No public key to verify with.');\n      }\n    };\n  }\n\n  if(env.nodejs) {\n    // node.js 8+\n    const crypto = require('crypto');\n    if('RSA_PKCS1_PSS_PADDING' in crypto.constants) {\n      return {\n        async verify({data, signature}) {\n          const verifier = crypto.createVerify('RSA-SHA256');\n          verifier.update(\n            Buffer.from(data.buffer, data.byteOffset, data.length));\n          return verifier.verify({\n            key: key.publicKeyPem,\n            padding: crypto.constants.RSA_PKCS1_PSS_PADDING,\n            saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST\n          }, Buffer.from(\n            signature.buffer, signature.byteOffset, signature.length));\n        }\n      };\n    }\n  }\n\n  // browser or other environment (including node 6.x)\n  const publicKey = forge.pki.publicKeyFromPem(key.publicKeyPem);\n  return {\n    async verify({data, signature}) {\n      const pss = createPss();\n      const md = forge.md.sha256.create();\n      md.update(forge.util.binary.raw.encode(data), 'binary');\n      try {\n        return publicKey.verify(\n          md.digest().bytes(),\n          forge.util.binary.raw.encode(signature),\n          pss);\n      } catch(e) {\n        // simply return false, do return information about malformed signature\n        return false;\n      }\n    }\n  };\n}\n\nfunction createPss() {\n  const md = forge.md.sha256.create();\n  return forge.pss.create({\n    md,\n    mgf: forge.mgf.mgf1.create(forge.md.sha256.create()),\n    saltLength: md.digestLength\n  });\n}\n\nmodule.exports = {\n  LDKeyPair,\n  Ed25519KeyPair,\n  RSAKeyPair\n};\n","/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\n// load locally embedded contexts\nconst contexts = require('./contexts');\n\nconst api = {};\nmodule.exports = api;\n\napi.extendContextLoader = documentLoader => {\n  return async url => {\n    const context = contexts[url];\n    if(context !== undefined) {\n      return {\n        contextUrl: null,\n        documentUrl: url,\n        document: context\n      };\n    }\n    return documentLoader(url);\n  };\n};\n\napi.strictDocumentLoader = api.extendContextLoader(url => {\n  throw new Error(`${url} not found.`);\n});\n","/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst ControllerProofPurpose = require('./ControllerProofPurpose');\n\nmodule.exports = class PublicKeyProofPurpose extends ControllerProofPurpose {\n  constructor({controller, date, maxTimestampDelta = Infinity} = {}) {\n    super({term: 'publicKey', controller, date, maxTimestampDelta});\n  }\n\n  async update(proof) {\n    // do not add `term` to proof\n    return proof;\n  }\n\n  async match(proof) {\n    // `proofPurpose` must not be present in the proof to match as this\n    // proof purpose is a legacy, non-descript purpose for signing\n    return proof.proofPurpose === undefined;\n  }\n};\n","/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nmodule.exports = class ProofPurpose {\n  /**\n   * @param term {string} the `proofPurpose` term, as defined in the\n   *    SECURITY_CONTEXT_URL `@context` or a URI if not defined in such.\n   * @param [date] {string or Date or integer} the expected date for\n   *   the creation of the proof.\n   * @param [maxTimestampDelta] {integer} a maximum number of seconds that\n   *   the date on the signature can deviate from, defaults to `Infinity`.\n   */\n  constructor({term, date, maxTimestampDelta = Infinity} = {}) {\n    if(term === undefined) {\n      throw new Error('\"term\" is required.');\n    }\n    if(maxTimestampDelta !== undefined &&\n      typeof maxTimestampDelta !== 'number') {\n      throw new TypeError('\"maxTimestampDelta\" must be a number.');\n    }\n    this.term = term;\n    if(date !== undefined) {\n      this.date = new Date(date);\n      if(isNaN(this.date)) {\n        throw TypeError(`\"date\" \"${date}\" is not a valid date.`);\n      }\n    }\n    this.maxTimestampDelta = maxTimestampDelta;\n  }\n\n  /**\n   * Called to validate the purpose of a proof. This method is called during\n   * proof verification, after the proof value has been checked against the\n   * given verification method (e.g. in the case of a digital signature, the\n   * signature has been cryptographically verified against the public key).\n   *\n   * @param proof {object} the proof, in the `constants.SECURITY_CONTEXT_URL`,\n   *   with the matching purpose to validate.\n   *\n   * @return {Promise<object>} resolves to an object with `valid` and `error`.\n   */\n  async validate(\n    proof, {document, suite, verificationMethod,\n      documentLoader, expansionMap}) {\n    try {\n      // check expiration\n      if(this.maxTimestampDelta !== Infinity) {\n        const expected = (this.date || new Date()).getTime();\n        const delta = this.maxTimestampDelta * 1000;\n        const created = new Date(proof.created).getTime();\n        // comparing this way handles NaN case where `created` is invalid\n        if(!(created >= (expected - delta) && created <= (expected + delta))) {\n          throw new Error('The proof\\'s created timestamp is out of range.');\n        }\n      }\n      return {valid: true};\n    } catch(error) {\n      return {valid: false, error};\n    }\n  }\n\n  /**\n   * Called to update a proof when it is being created, adding any properties\n   * specific to this purpose. This method is called prior to the proof\n   * value being generated such that any properties added may be, for example,\n   * included in a digital signature value.\n   *\n   * @param proof {object} the proof, in the `constants.SECURITY_CONTEXT_URL`\n   *   to update.\n   *\n   * @return {Promise<object>} resolves to the proof instance (in the\n   *   `constants.SECURITY_CONTEXT_URL`.\n   */\n  async update(proof, {document, suite, documentLoader, expansionMap}) {\n    proof.proofPurpose = this.term;\n    return proof;\n  }\n\n  /**\n   * Determines if the given proof has a purpose that matches this instance,\n   * i.e. this ProofPurpose instance should be used to validate the given\n   * proof.\n   *\n   * @param proof {object} the proof to check.\n   *\n   * @return {Promise<boolean>} `true` if there's a match, `false` if not.\n   */\n  async match(proof, {document, documentLoader, expansionMap}) {\n    return proof.proofPurpose === this.term;\n  }\n};\n","/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nmodule.exports = class LinkedDataProof {\n  constructor({type} = {}) {\n    if(typeof type !== 'string') {\n      throw new TypeError('A LinkedDataProof must have a \"type\".');\n    }\n    this.type = type;\n  }\n\n  /**\n   * @param document {object} to be signed.\n   * @param purpose {ProofPurpose}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   * @param compactProof {boolean}\n   *\n   * @returns {Promise<object>} Resolves with the created proof object.\n   */\n  async createProof(\n    {document, purpose, documentLoader, expansionMap, compactProof}) {\n    throw new Error('\"createProof\" must be implemented in a derived class.');\n  }\n\n  /**\n   * @param proof {object} the proof to be verified.\n   * @param document {object} the document the proof applies to.\n   * @param purpose {ProofPurpose}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   *\n   * @returns {Promise<{object}>} Resolves with the verification result.\n   */\n  async verifyProof({proof, document, purpose, documentLoader, expansionMap}) {\n    throw new Error('\"verifyProof\" must be implemented in a derived class.');\n  }\n\n  /**\n   * @param proof {object} the proof to be matched.\n   * @param document {object} the document the proof applies to.\n   * @param purpose {ProofPurpose}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   *\n   * @returns {Promise<{boolean}>} Resolves with the verification result.\n   */\n  async matchProof({proof, document, purpose, documentLoader, expansionMap}) {\n    return proof.type === this.type;\n  }\n};\n","/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst LinkedDataSignature = require('./LinkedDataSignature');\nconst jsonld = require('jsonld');\nconst util = require('../util');\n\nmodule.exports = class JwsLinkedDataSignature extends LinkedDataSignature {\n  /**\n   * @param type {string} Provided by subclass.\n   * @param alg {string} JWS alg provided by subclass.\n   * @param [LDKeyClass] {LDKeyClass} provided by subclass or subclass\n   *   overrides `getVerificationMethod`.\n   *\n   * One of these parameters is required to use a suite for signing:\n   *\n   * @param [creator] {string} A key id URL to the paired public key.\n   * @param [verificationMethod] {string} A key id URL to the paired public key.\n   *\n   * This parameter is required for signing:\n   *\n   * @param [signer] {function} an optional signer.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param [proof] {object} a JSON-LD document with options to use for\n   *   the `proof` node (e.g. any other custom fields can be provided here\n   *   using a context different from security-v2).\n   * @param [date] {string|Date} signing date to use if not passed.\n   * @param [key] {LDKeyPair} an optional crypto-ld KeyPair.\n   */\n  constructor({\n    type, alg, LDKeyClass, creator, verificationMethod, signer, key, proof,\n    date} = {}) {\n    super({\n      type, creator, verificationMethod, proof, date});\n    this.alg = alg;\n    this.LDKeyClass = LDKeyClass;\n    this.signer = signer;\n    if(key) {\n      if(verificationMethod === undefined && creator === undefined) {\n        const publicKey = key.publicNode();\n        if(publicKey.controller) {\n          // assume newer signature terms\n          this.verificationMethod = publicKey.id;\n        } else {\n          // assume legacy signature terms\n          this.creator = publicKey.id;\n        }\n      }\n      this.key = key;\n      this.signer = key.signer();\n      this.verifier = key.verifier();\n    }\n  }\n\n  /**\n   * @param verifyData {Uint8Array}.\n   * @param proof {object}\n   *\n   * @returns {Promise<{object}>} the proof containing the signature value.\n   */\n  async sign({verifyData, proof}) {\n    // JWS header\n    const header = {\n      alg: this.alg,\n      b64: false,\n      crit: ['b64']\n    };\n\n    /*\n    +-------+-----------------------------------------------------------+\n    | \"b64\" | JWS Signing Input Formula                                 |\n    +-------+-----------------------------------------------------------+\n    | true  | ASCII(BASE64URL(UTF8(JWS Protected Header)) || '.' ||     |\n    |       | BASE64URL(JWS Payload))                                   |\n    |       |                                                           |\n    | false | ASCII(BASE64URL(UTF8(JWS Protected Header)) || '.') ||    |\n    |       | JWS Payload                                               |\n    +-------+-----------------------------------------------------------+\n    */\n\n    // create JWS data and sign\n    const encodedHeader = util.encodeBase64Url(JSON.stringify(header));\n    const data = util.createJws({encodedHeader, verifyData});\n    const signature = await this.signer.sign({data});\n\n    // create detached content signature\n    const encodedSignature = util.encodeBase64Url(signature);\n    proof.jws = encodedHeader + '..' + encodedSignature;\n    return proof;\n  }\n\n  /**\n   * @param verifyData {Uint8Array}.\n   * @param verificationMethod {object}.\n   * @param document {object} the document the proof applies to.\n   * @param proof {object} the proof to be verified.\n   * @param purpose {ProofPurpose}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   *\n   * @returns {Promise<{boolean}>} Resolves with the verification result.\n   */\n  async verifySignature({verifyData, verificationMethod, proof}) {\n    // add payload into detached content signature\n    const [encodedHeader, /*payload*/, encodedSignature] = proof.jws.split('.');\n\n    let header;\n    try {\n      header = JSON.parse(util.decodeBase64UrlToString(encodedHeader));\n    } catch(e) {\n      throw new Error('Could not parse JWS header; ' + e);\n    }\n    if(!(header && typeof header === 'object')) {\n      throw new Error('Invalid JWS header.');\n    }\n\n    // confirm header matches all expectations\n    if(!(header.alg === this.alg && header.b64 === false &&\n      Array.isArray(header.crit) && header.crit.length === 1 &&\n      header.crit[0] === 'b64') && Object.keys(header).length === 3) {\n      throw new Error(\n        `Invalid JWS header parameters for ${this.type}.`);\n    }\n\n    // do signature verification\n    const signature = util.decodeBase64Url(encodedSignature);\n    const data = util.createJws({encodedHeader, verifyData});\n    let {verifier} = this;\n    if(!verifier) {\n      const key = await this.LDKeyClass.from(verificationMethod);\n      verifier = key.verifier();\n    }\n    return verifier.verify({data, signature});\n  }\n\n  async assertVerificationMethod({verificationMethod}) {\n    if(!jsonld.hasValue(verificationMethod, 'type', this.requiredKeyType)) {\n      throw new Error(\n        `Invalid key type. Key type must be \"${this.requiredKeyType}\".`);\n    }\n  }\n\n  async getVerificationMethod({proof, documentLoader}) {\n    if(this.key) {\n      return this.key.publicNode();\n    }\n\n    const verificationMethod = await super.getVerificationMethod(\n      {proof, documentLoader});\n    await this.assertVerificationMethod({verificationMethod});\n    return verificationMethod;\n  }\n\n  async matchProof({proof, document, purpose, documentLoader, expansionMap}) {\n    if(!await super.matchProof(\n      {proof, document, purpose, documentLoader, expansionMap})) {\n      return false;\n    }\n    if(!this.key) {\n      // no key specified, so assume this suite matches and it can be retrieved\n      return true;\n    }\n\n    let {verificationMethod} = proof;\n    if(!verificationMethod) {\n      verificationMethod = proof.creator;\n    }\n    // only match if the key specified matches the one in the proof\n    if(typeof verificationMethod === 'object') {\n      return verificationMethod.id === this.key.id;\n    }\n    return verificationMethod === this.key.id;\n  }\n};\n","/*!\n * Copyright (c) 2010-2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\n/* Core API */\nconst api = {};\nmodule.exports = api;\n\n/* API Constants */\nconst constants = require('./constants');\nObject.assign(api, constants);\n\n// TODO: support `ProofChain`\nconst ProofSet = require('./ProofSet');\n\napi.sign = async function sign(document, {\n  suite, purpose, documentLoader, expansionMap, compactProof} = {}) {\n  try {\n    return await new ProofSet().add(\n      document, {suite, purpose, documentLoader, expansionMap, compactProof});\n  } catch(e) {\n    if(!documentLoader && e.name === 'jsonld.InvalidUrl') {\n      const {details: {url}} = e;\n      const err = new Error(\n        `A URL \"${url}\" could not be fetched; you need to pass ` +\n        '\"documentLoader\" or resolve the URL before calling \"sign\".');\n      err.cause = e;\n      throw err;\n    }\n    throw e;\n  }\n};\n\napi.verify = async function verify(document, {\n  suite, purpose, documentLoader, expansionMap, compactProof} = {}) {\n  const result = await new ProofSet().verify(\n    document, {suite, purpose, documentLoader, expansionMap, compactProof});\n  if(!documentLoader && result.error) {\n    const {error} = result;\n    if(error.name === 'jsonld.InvalidUrl') {\n      const {details: {url}} = error;\n      const err = new Error(\n        `A URL \"${url}\" could not be fetched; you need to pass ` +\n        '\"documentLoader\" or resolve the URL before calling \"verify\".');\n      err.cause = error;\n      result.error = err;\n    }\n  }\n  return result;\n};\n\n// expose suite classes\napi.suites = require('./suites').suites;\n\n// expose ProofPurpose classes to enable extensions\napi.purposes = require('./purposes').purposes;\n\n// expose LDKeyPair classes\nObject.assign(api, require('./LDKeyPair'));\n\n// expose document loader helpers\nObject.assign(api, require('./documentLoader'));\n","/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst constants = require('./constants');\nconst jsonld = require('jsonld');\nconst {extendContextLoader, strictDocumentLoader} = require('./documentLoader');\nconst strictExpansionMap = require('./expansionMap');\nconst PublicKeyProofPurpose = require('./purposes/PublicKeyProofPurpose');\n\nmodule.exports = class ProofSet {\n  /**\n   * Adds a Linked Data proof to a document. If the document contains other\n   * proofs, the new proof will be appended to the existing set of proofs.\n   *\n   * Important note: This method assumes that the term `proof` in the given\n   * document has the same definition as the `https://w3id.org/security/v2`\n   * JSON-LD @context.\n   *\n   * @param document {object|string} Object to be signed, either a string URL\n   *   (resolved via the given `documentLoader`) or a plain object (JSON-LD\n   *   document).\n   * @param options {object} Options hashmap.\n   *\n   * A `suite` option is required:\n   *\n   * @param options.suite {LinkedDataSignature} a signature suite instance\n   *   that will create the proof.\n   *\n   * A `purpose` option is required:\n   *\n   * @param options.purpose {ProofPurpose} a proof purpose instance that will\n   *   augment the proof with information describing its intended purpose.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param [documentLoader] {function} a custom document loader,\n   *   `Promise<RemoteDocument> documentLoader(url)`.\n   * @param [expansionMap] {function} A custom expansion map that is\n   *   passed to the JSON-LD processor; by default a function that will throw\n   *   an error when unmapped properties are detected in the input, use `false`\n   *   to turn this off and allow unmapped properties to be dropped or use a\n   *   custom function.\n   * @param [compactProof] {boolean} `true` instructs this call to compact\n   *   the resulting proof to the same JSON-LD `@context` as the input\n   *   document; this is the default behavior. Setting this flag to `false` can\n   *   be used as an optimization to prevent an unnecessary compaction when the\n   *   caller knows that all used proof terms have the same definition in the\n   *   document's `@context` as the `constants.SECURITY_CONTEXT_URL` `@context`.\n   *\n   * @return {Promise<object>} resolves with the signed document, with\n   *   the signature in the top-level `proof` property.\n   */\n  async add(document, {\n    suite, purpose, documentLoader, expansionMap,\n    compactProof = true} = {}) {\n    if(!suite) {\n      throw new TypeError('\"options.suite\" is required.');\n    }\n    if(!purpose) {\n      throw new TypeError('\"options.purpose\" is required.');\n    }\n\n    if(suite.legacy) {\n      if(!(purpose instanceof PublicKeyProofPurpose)) {\n        throw new TypeError(\n          `The \"${suite.type}\" suite requires \"options.purpose\" to be ` +\n          'an instance of \"PublicKeyProofPurpose\".');\n      }\n    }\n\n    if(documentLoader) {\n      documentLoader = extendContextLoader(documentLoader);\n    } else {\n      documentLoader = strictDocumentLoader;\n    }\n    if(expansionMap !== false) {\n      expansionMap = strictExpansionMap;\n    }\n\n    if(typeof document === 'string') {\n      // fetch document\n      document = await documentLoader(document);\n    }\n\n    // preprocess document to prepare to remove existing proofs\n    let input;\n    if(compactProof) {\n      // cannot assume security context terms, so do full compaction\n      input = await jsonld.compact(\n        document, constants.SECURITY_CONTEXT_URL,\n        {documentLoader, expansionMap, compactToRelative: false});\n    } else {\n      // TODO: optimize to modify document in place to maximize optimization\n\n      // shallow copy document to allow removal of existing proofs\n      input = {...document};\n    }\n\n    // save but exclude any existing proof(s)\n    const proofProperty = suite.legacy ? 'signature' : 'proof';\n    //const existingProofs = input[proofProperty];\n    delete input[proofProperty];\n\n    // create the new proof (suites MUST output a proof using the security-v2\n    // `@context`)\n    const proof = await suite.createProof({\n      document: input, purpose, documentLoader,\n      expansionMap, compactProof});\n\n    if(compactProof) {\n      // compact proof to match document's context\n      let expandedProof;\n      if(suite.legacy) {\n        expandedProof = {\n          [constants.SECURITY_SIGNATURE_URL]: proof\n        };\n      } else {\n        expandedProof = {\n          [constants.SECURITY_PROOF_URL]: {'@graph': proof}\n        };\n      }\n      const ctx = jsonld.getValues(document, '@context');\n      const compactProof = await jsonld.compact(\n        expandedProof, ctx,\n        {documentLoader, expansionMap, compactToRelative: false});\n      delete compactProof['@context'];\n\n      // add proof to document\n      const key = Object.keys(compactProof)[0];\n      jsonld.addValue(document, key, compactProof[key]);\n    } else {\n      // in-place restore any existing proofs\n      /*if(existingProofs) {\n        document[proofProperty] = existingProofs;\n      }*/\n      // add new proof\n      delete proof['@context'];\n      jsonld.addValue(document, proofProperty, proof);\n    }\n\n    return document;\n  }\n\n  /**\n   * Verify Linked Data proof(s) on a document. The proofs to be verified\n   * must match the given proof purpose.\n   *\n   * Important note: This method assumes that the term `proof` in the given\n   * document has the same definition as the `https://w3id.org/security/v2`\n   * JSON-LD @context.\n   *\n   * @param document {object|string} Object with one or more proofs to be\n   *   verified, either a string URL (resolved to an object via the given\n   *   `documentLoader`) or a plain object (JSON-LD document).\n   * @param options {object} Options hashmap.\n   *\n   * A `suite` option is required:\n   *\n   * @param options.suite {LinkedDataSignature or Array of LinkedDataSignature}\n   *   acceptable signature suite instances for verifying the proof(s).\n   *\n   * A `purpose` option is required:\n   *\n   * @param options.purpose {ProofPurpose} a proof purpose instance that will\n   *   match proofs to be verified and ensure they were created according to\n   *   the appropriate purpose.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param [documentLoader] {function} a custom document loader,\n   *   `Promise<RemoteDocument> documentLoader(url)`.\n   * @param [expansionMap] {function} A custom expansion map that is\n   *   passed to the JSON-LD processor; by default a function that will throw\n   *   an error when unmapped properties are detected in the input, use `false`\n   *   to turn this off and allow unmapped properties to be dropped or use a\n   *   custom function.\n   * @param [compactProof] {boolean} `true` indicates that this method cannot\n   *   assume that the incoming document has defined all proof terms in the\n   *   same way as the `constants.SECURITY_CONTEXT_URL` JSON-LD `@context`.\n   *   This means that this method must compact any found proofs to this\n   *   context for internal and extension processing; this is the default\n   *   behavior. To override this behavior and optimize away this step because\n   *   the caller knows that the input document's JSON-LD `@context` defines\n   *   the proof terms in the same way, set this flag to `false`.\n   *\n   * @return {Promise<object>} resolves with an object with a `verified`\n   *   boolean property that is `true` if at least one proof matching the\n   *   given purpose and suite verifies and `false` otherwise; a `results`\n   *   property with an array of detailed results; if `false` an `error`\n   *   property will be present.\n   */\n  async verify(document, {\n    suite, purpose, documentLoader, expansionMap,\n    compactProof = true} = {}) {\n    if(!suite) {\n      throw new TypeError('\"options.suite\" is required.');\n    }\n    if(!purpose) {\n      throw new TypeError('\"options.purpose\" is required.');\n    }\n    const suites = Array.isArray(suite) ? suite : [suite];\n    if(suites.length === 0) {\n      throw new TypeError('At least one suite is required.');\n    }\n\n    const legacy = suites.some(s => s.legacy);\n    if(legacy) {\n      if(suites.some(s => !s.legacy)) {\n        throw new Error(\n          'Legacy suites may not be combined with current suites.');\n      } else if(!(purpose instanceof PublicKeyProofPurpose)) {\n        throw new TypeError(\n          '\"options.purpose\" must be an instance of \"PublicKeyProofPurpose\"' +\n          'to use a legacy suite.');\n      }\n    }\n\n    if(documentLoader) {\n      documentLoader = extendContextLoader(documentLoader);\n    } else {\n      documentLoader = strictDocumentLoader;\n    }\n    if(expansionMap !== false) {\n      expansionMap = strictExpansionMap;\n    }\n\n    try {\n      if(typeof document === 'string') {\n        // fetch document\n        document = await documentLoader(document);\n      } else {\n        // TODO: consider in-place editing to optimize when `compactProof`\n        // is `false`\n\n        // shallow copy to allow for removal of proof set prior to canonize\n        document = {...document};\n      }\n\n      // get proofs from document\n      const {proofSet, document: doc} = await _getProofs({\n        document, legacy, documentLoader, expansionMap, compactProof});\n      document = doc;\n\n      // verify proofs\n      const results = await _verify({\n        document, suites, proofSet,\n        purpose, documentLoader, expansionMap, compactProof});\n      if(results.length === 0) {\n        throw new Error(\n          'Could not verify any proofs; no proofs matched the required ' +\n          'suite and purpose.');\n      }\n\n      // combine results\n      const verified = results.some(r => r.verified);\n      if(!verified) {\n        const errors = [].concat(\n          ...results.filter(r => r.error).map(r => r.error));\n        const result = {verified, results};\n        if(errors.length > 0) {\n          result.error = errors;\n        }\n        return result;\n      }\n      return {verified, results};\n    } catch(error) {\n      return {verified: false, error};\n    }\n  }\n};\n\nasync function _getProofs({\n  document, legacy, documentLoader, expansionMap, compactProof}) {\n  // handle document preprocessing to find proofs\n  const proofProperty = legacy ? 'signature' : 'proof';\n  let proofSet;\n  if(compactProof) {\n    // if we must compact the proof(s) then we must first compact the input\n    // document to find the proof(s)\n    document = await jsonld.compact(\n      document, constants.SECURITY_CONTEXT_URL,\n      {documentLoader, expansionMap, compactToRelative: false});\n  }\n  proofSet = jsonld.getValues(document, proofProperty);\n  delete document[proofProperty];\n\n  if(proofSet.length === 0) {\n    // no possible matches\n    throw new Error('No matching proofs found in the given document.');\n  }\n\n  // TODO: consider in-place editing to optimize\n\n  // shallow copy proofs and add SECURITY_CONTEXT_URL\n  proofSet = proofSet.map(proof => ({\n    '@context': constants.SECURITY_CONTEXT_URL,\n    ...proof\n  }));\n\n  return {proofSet, document};\n}\n\nasync function _verify({\n  document, suites, proofSet, purpose,\n  documentLoader, expansionMap, compactProof}) {\n  // filter out matching proofs\n  const result = await Promise.all(proofSet.map(proof =>\n    purpose.match(proof, {document, documentLoader, expansionMap})));\n  const matches = proofSet.filter((value, index) => result[index]);\n  if(matches.length === 0) {\n    // no matches, nothing to verify\n    return [];\n  }\n\n  // verify each matching proof\n  return (await Promise.all(matches.map(async proof => {\n    for(const s of suites) {\n      if(await s.matchProof({proof, document, documentLoader, expansionMap})) {\n        return s.verifyProof({\n          proof, document, purpose, documentLoader, expansionMap,\n          compactProof}).catch(error => ({verified: false, error}));\n      }\n    }\n  }))).map((r, i) => r ? {proof: matches[i], ...r} : null).filter(r => r);\n}\n","/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\n// strict expansion map disallows dropping properties when expanding by default\nmodule.exports = info => {\n  if(info.unmappedProperty) {\n    throw new Error('The property \"' +\n       info.unmappedProperty + '\" in the input ' +\n      'was not defined in the context.');\n  }\n};\n","/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst api = {};\nmodule.exports = api;\n\n// TODO: only require dynamically as needed or according to build\napi.suites = {\n  EcdsaKoblitzSignature2016: require('./suites/EcdsaKoblitzSignature2016'),\n  Ed25519Signature2018: require('./suites/Ed25519Signature2018'),\n  LinkedDataProof: require('./suites/LinkedDataProof'),\n  LinkedDataSignature: require('./suites/LinkedDataSignature'),\n  LinkedDataSignature2015: require('./suites/LinkedDataSignature2015'),\n  GraphSignature2012: require('./suites/GraphSignature2012'),\n  RsaSignature2018: require('./suites/RsaSignature2018')\n};\n","/*!\n * Copyright (c) 2017-2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst forge = require('node-forge');\nconst LinkedDataSignature2015 = require('./LinkedDataSignature2015');\n\nmodule.exports = class EcdsaKoblitzSignature2016\n  extends LinkedDataSignature2015 {\n  constructor({\n    privateKeyWif, publicKeyWif, creator, date, domain, nonce} = {}) {\n    super({\n      type: 'EcdsaKoblitzSignature2016',\n      creator, date, domain, nonce});\n    this.privateKeyWif = privateKeyWif;\n    this.publicKeyWif = publicKeyWif;\n  }\n\n  async sign({verifyData, proof}) {\n    if(typeof this.privateKeyWif !== 'string') {\n      throw new TypeError('\"privateKeyWif\" must be a base58 formatted string.');\n    }\n\n    const bitcoreMessage = require('bitcore-message');\n    const bitcore = bitcoreMessage.Bitcore;\n    const privateKey = bitcore.PrivateKey.fromWIF(this.privateKeyWif);\n    const message = bitcoreMessage(forge.util.binary.raw.encode(verifyData));\n    proof.signatureValue = message.sign(privateKey);\n\n    return proof;\n  }\n\n  async verifySignature({verifyData, proof}) {\n    const bitcoreMessage = require('bitcore-message');\n    const message = bitcoreMessage(forge.util.binary.raw.encode(verifyData));\n    return message.verify(this.publicKeyWif, proof.signatureValue);\n  }\n\n  async getVerificationMethod({proof, documentLoader}) {\n    const verificationMethod = await super.getVerificationMethod(\n      {proof, documentLoader});\n    if(typeof verificationMethod.publicKeyWif !== 'string') {\n      throw new TypeError(\n        'Unknown public key encoding. Public key encoding must be ' +\n        '\"publicKeyWif\".');\n    }\n    if(!this.publicKeyWif) {\n      this.publicKeyWif = verificationMethod.publicKeyWif;\n    }\n    return verificationMethod;\n  }\n};\n","/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst {Ed25519KeyPair} = require('../LDKeyPair');\nconst JwsLinkedDataSignature = require('./JwsLinkedDataSignature');\n\nmodule.exports = class Ed25519Signature2018 extends JwsLinkedDataSignature {\n  /**\n   * @param type {string} Provided by subclass.\n   *\n   * One of these parameters is required to use a suite for signing:\n   *\n   * @param [creator] {string} A key id URL to the paired public key.\n   * @param [verificationMethod] {string} A key id URL to the paired public key.\n   *\n   * This parameter is required for signing:\n   *\n   * @param [signer] {function} an optional signer.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param [proof] {object} a JSON-LD document with options to use for\n   *   the `proof` node (e.g. any other custom fields can be provided here\n   *   using a context different from security-v2).\n   * @param [date] {string|Date} signing date to use if not passed.\n   * @param [key] {LDKeyPair} an optional crypto-ld KeyPair.\n   */\n  constructor({signer, key, creator, verificationMethod, proof, date} = {}) {\n    super({\n      type: 'Ed25519Signature2018', alg: 'EdDSA', LDKeyClass: Ed25519KeyPair,\n      creator, verificationMethod, signer, key, proof, date});\n    this.requiredKeyType = 'Ed25519VerificationKey2018';\n  }\n};\n","/*!\n * Copyright (c) 2017-2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst jsonld = require('jsonld');\nconst forge = require('node-forge');\nconst LinkedDataSignature2015 = require('./LinkedDataSignature2015');\n\nmodule.exports = class GraphSignature2012 extends LinkedDataSignature2015 {\n  constructor({\n    privateKeyPem, publicKeyPem, creator, date, domain, nonce} = {}) {\n    super({\n      type: 'GraphSignature2012',\n      privateKeyPem, publicKeyPem,\n      creator, date, domain, nonce});\n  }\n\n  async canonize(\n    input, {documentLoader, expansionMap, skipExpansion}) {\n    return jsonld.canonize(input, {\n      algorithm: 'URGNA2012',\n      format: 'application/n-quads',\n      documentLoader,\n      expansionMap,\n      skipExpansion\n    });\n  }\n\n  /**\n   * @param document {object} to be signed/verified.\n   * @param proof {object}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   * @param compactProof {boolean}\n   *\n   * @returns {Promise<{Uint8Array}>}.\n   */\n  async createVerifyData({\n    document, proof, documentLoader, expansionMap}) {\n    const c14n = await this.canonize(document, {\n      documentLoader,\n      expansionMap\n    });\n\n    let verifyData = '';\n    if(proof.nonce !== null && proof.nonce !== undefined) {\n      verifyData += proof.nonce;\n    }\n    verifyData += proof.created;\n    verifyData += c14n;\n    if(proof.domain !== null && proof.domain !== undefined) {\n      verifyData += '@' + proof.domain;\n    }\n    const buffer = new forge.util.ByteBuffer(verifyData, 'utf8');\n    return forge.util.binary.raw.decode(buffer.getBytes());\n  }\n};\n","/*!s\n * Copyright (c) 2017-2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst {RSAKeyPair} = require('../LDKeyPair');\nconst JwsLinkedDataSignature = require('./JwsLinkedDataSignature');\n\nmodule.exports = class RsaSignature2018 extends JwsLinkedDataSignature {\n  /**\n   * @param type {string} Provided by subclass.\n   *\n   * One of these parameters is required to use a suite for signing:\n   *\n   * @param [creator] {string} A key id URL to the paired public key.\n   * @param [verificationMethod] {string} A key id URL to the paired public key.\n   *\n   * This parameter is required for signing:\n   *\n   * @param [signer] {function} an optional signer.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param [proof] {object} a JSON-LD document with options to use for\n   *   the `proof` node (e.g. any other custom fields can be provided here\n   *   using a context different from security-v2).\n   * @param [date] {string|Date} signing date to use if not passed.\n   * @param [key] {LDKeyPair} an optional crypto-ld KeyPair.\n   */\n  constructor({signer, key, creator, verificationMethod, proof, date} = {}) {\n    super({\n      type: 'RsaSignature2018', alg: 'PS256', LDKeyClass: RSAKeyPair,\n      creator, verificationMethod, signer, key, proof, date});\n    this.requiredKeyType = 'RsaVerificationKey2018';\n  }\n};\n","/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst api = {};\nmodule.exports = api;\n\n// TODO: only require dynamically as needed or according to build\napi.purposes = {\n  AssertionProofPurpose: require('./purposes/AssertionProofPurpose'),\n  AuthenticationProofPurpose: require('./purposes/AuthenticationProofPurpose'),\n  ControllerProofPurpose: require('./purposes/ControllerProofPurpose'),\n  ProofPurpose: require('./purposes/ProofPurpose'),\n  PublicKeyProofPurpose: require('./purposes/PublicKeyProofPurpose')\n};\n","/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst ControllerProofPurpose = require('./ControllerProofPurpose');\n\nmodule.exports = class AssertionProofPurpose extends ControllerProofPurpose {\n  constructor({\n    term = 'assertionMethod', controller,\n    date, maxTimestampDelta = Infinity} = {}) {\n    super({term, controller, date, maxTimestampDelta});\n  }\n};\n","/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst ControllerProofPurpose = require('./ControllerProofPurpose');\n\nmodule.exports = class AuthenticationProofPurpose extends\n  ControllerProofPurpose {\n  constructor({\n    term = 'authentication', controller,\n    challenge, date, domain, maxTimestampDelta = Infinity} = {}) {\n    super({term, controller, date, maxTimestampDelta});\n    if(typeof challenge !== 'string') {\n      throw new TypeError('\"challenge\" must be a string.');\n    }\n    if(domain !== undefined && typeof domain !== 'string') {\n      throw new TypeError('\"domain\" must be a string.');\n    }\n    this.challenge = challenge;\n    this.domain = domain;\n  }\n\n  async validate(proof, {verificationMethod, documentLoader, expansionMap}) {\n    try {\n      // check challenge\n      if(proof.challenge !== this.challenge) {\n        throw new Error('The challenge is not as expected; ' +\n          `challenge=\"${proof.challenge}\", expected=\"${this.challenge}\"`);\n      }\n\n      // check domain\n      if(this.domain !== undefined && proof.domain !== this.domain) {\n        throw new Error('The domain is not as expected; ' +\n          `domain=\"${proof.domain}\", expected=\"${this.domain}\"`);\n      }\n\n      return super.validate(\n        proof, {verificationMethod, documentLoader, expansionMap});\n    } catch(error) {\n      return {valid: false, error};\n    }\n  }\n\n  async update(proof, {document, suite, documentLoader, expansionMap}) {\n    proof = await super.update(\n      proof, {document, suite, documentLoader, expansionMap});\n    proof.challenge = this.challenge;\n    if(this.domain !== undefined) {\n      proof.domain = this.domain;\n    }\n    return proof;\n  }\n};\n"],"mappings":"AAAA;;;ACKA;;;ACAA;;;ACAA;;;ACCA;;;ACDA;;;ACAA;;;ACCA;;;ACDA;;;ACAA;;;ACAA;;;ACAA;;;ACCA;;;ACDA;;;ACCA;;;ACDA;;;ACAA;;;ACAA;;;ACAA;;;ACAA;;;ACAA;;;ACAA;;;ACAA","sourceRoot":""}